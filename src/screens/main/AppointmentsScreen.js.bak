import React, { useState, useRef, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  Animated,
  Dimensions,
  StatusBar,
  Easing,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import colors from '../../constants/colors';

// Importar componentes
import CalendarHeader from './components/CalendarHeader';
import CalendarDay from './components/CalendarDay';
import TimelineView from './components/TimelineView';

// Importar utilidades
import { isSameDay, formatSelectedDate, formatTime, calculateEndTime } from './utils/appointmentUtils';

// Importar estilos
import styles from './styles/AppointmentsScreenStyles';

// Using formatSelectedDate from imported utils

const { width } = Dimensions.get('window');

const daysOfWeek = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
const monthsOfYear = [
  'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
  'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
];

export default function AppointmentsScreen() {
  const navigation = useNavigation();
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
  const [calendarDays, setCalendarDays] = useState([]);
  const [appointments, setAppointments] = useState([]);
  const [isCalendarExpanded, setIsCalendarExpanded] = useState(false);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [viewMode, setViewMode] = useState('day'); // day, week, month
  const [zoomScale, setZoomScale] = useState(1); // Factor de escala para el zoom (1 = normal)
  
  const calendarAnimation = useRef(new Animated.Value(0)).current;
  const scrollViewRef = useRef(null);
  const timelineScrollRef = useRef(null);
  const initialScale = useRef(1);
  const isPinching = useRef(false); // Nueva referencia para detectar si estamos en un gesto de pellizco
  const lastZoomChangeTime = useRef(0);
  const ZOOM_DEBOUNCE_TIME = 400; // Tiempo más largo entre cambios para evitar activaciones múltiples
  
  // Referencia para almacenar la posición de scroll actual
  const currentScrollPosition = useRef(0);
  
  // Implementación mejorada del gesto de zoom con animación fluida y preservando la posición de scroll
  const pinchGesture = Gesture.Pinch()
    .onBegin(() => {
      initialScale.current = zoomScale;
      isPinching.current = true; // Marcamos que ha comenzado un gesto de pellizco
      
      // Guardamos la posición actual del scroll al iniciar el pellizco
      if (timelineScrollRef.current) {
        // No podemos acceder directamente al scrollY, así que usamos la última posición conocida
        // que actualizamos en el onScroll del ScrollView
      }
    })
    .onChange((e) => {
      // Límites de zoom ajustados para una mejor experiencia
      const MIN_ZOOM = 0.75;
      const MAX_ZOOM = 1.1;
      
      // Aplicamos zoom continuo con límites controlados
      const calculatedScale = e.scale * initialScale.current;
      const newScale = Math.min(Math.max(calculatedScale, MIN_ZOOM), MAX_ZOOM);
      
      // Aplicamos cambios directamente para mayor fluidez
      setZoomScale(newScale);
      
      // Prevenimos explícitamente cualquier auto-scroll durante el pellizco
      // No hacemos nada más aquí, solo aseguramos que isPinching sea true
      isPinching.current = true;
    })
    .onEnd(() => {
      // Marcamos que ha finalizado el gesto de pellizco después de un pequeño retraso
      // para evitar que el efecto de autodesplazamiento se active inmediatamente
      setTimeout(() => {
        isPinching.current = false;
      }, 500);
    });

  // Función optimizada para calcular la altura de cada slot de 15 minutos
  const getSlotHeight = useCallback(() => {
    // Altura base para cada intervalo de 15 minutos
    const baseHeight = 30;
    
    // Calculamos directamente la altura con el factor de zoom actual
    // sin procesamiento adicional para mayor fluidez
    let adjustedHeight = baseHeight * zoomScale;
    
    // Aseguramos límites para mantener la usabilidad
    const MIN_SLOT_HEIGHT = 20; 
    const MAX_SLOT_HEIGHT = 50;
    
    return Math.min(Math.max(adjustedHeight, MIN_SLOT_HEIGHT), MAX_SLOT_HEIGHT);
  }, [zoomScale]);
  
  // Función optimizada para calcular la posición del indicador de hora actual
  const calculateCurrentTimePosition = useCallback(() => {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    
    // Si estamos fuera del horario laboral, manejar de manera inteligente
    if (hours < 9) {
      return 0; // Al inicio del día, mostrar desde el principio
    }
    if (hours >= 18) {
      // Al final del día, mostrar última hora visible
      const totalSlots = (18 - 9) * 4; // Total de slots de 15min entre 9:00 y 18:00
      return totalSlots * getSlotHeight() - 60; // Ajustar para mostrar el final del día
    }
    
    // Cálculo preciso basado en la altura de los slots
    const hoursFromStart = hours - 9; // Las horas laborables comienzan a las 9:00
    const minutesAsDecimal = minutes / 60;
    const totalHoursFromStart = hoursFromStart + minutesAsDecimal;
    
    // Usar siempre slots de 15 minutos (4 por hora)
    const slotsPerHour = 4;
    
    return totalHoursFromStart * slotsPerHour * getSlotHeight();
  }, [getSlotHeight]); // Dependencia en getSlotHeight para recalcular si cambia el zoom
  
  // Generate calendar days for the current month
  useEffect(() => {
    generateCalendarDays();
  }, [selectedMonth, selectedYear]);
  
  // Fetch appointments for the selected date
  useEffect(() => {
    fetchAppointmentsForDate(selectedDate);
  }, [selectedDate]);
  
  // Load sample data for demonstration
  useEffect(() => {
    loadSampleAppointments();
  }, []);
  
  // Scroll automático SOLO cuando cambia la fecha seleccionada (nunca durante o después del zoom)
  useEffect(() => {
    // Variable para rastrear si este efecto fue llamado por un cambio de fecha
    const isDateChange = true; // Siempre true porque este efecto solo se activa con cambio de fecha
    
    // Solo ejecutamos el auto-scroll si:
    // 1. Es un cambio de fecha (no por zoom)
    // 2. No estamos en medio de un gesto de pellizco
    // 3. Estamos viendo el día actual
    // 4. El timeline scroll ref está disponible
    if (
      isDateChange &&
      !isPinching.current && 
      timelineScrollRef.current && 
      isSameDay(selectedDate, new Date())
    ) {
      // Esperamos menos tiempo para una respuesta más inmediata
      setTimeout(() => {
        // Verificamos nuevamente que no se haya iniciado un gesto de pellizco
        if (!isPinching.current) {
          const scrollPosition = calculateCurrentTimePosition() - 150; // Centrar mejor la hora actual
          if (scrollPosition > 0) {
            timelineScrollRef.current.scrollTo({ 
              y: scrollPosition, 
              animated: true,
              duration: 300 
            });
          }
        }
      }, 300);
    }
  }, [selectedDate]); // Solo dependemos de selectedDate, no del cálculo de posición
  
  // Animation for calendar expand/collapse - optimizada para mayor fluidez
  useEffect(() => {
    Animated.timing(calendarAnimation, {
      toValue: isCalendarExpanded ? 1 : 0,
      duration: 200, // Más rápida para mejor respuesta
      useNativeDriver: false, // No podemos usar driver nativo para height
      easing: Easing.bezier(0.25, 0.1, 0.25, 1), // Añadimos una curva de ease-out para suavidad
    }).start();
  }, [isCalendarExpanded]);
  
  const calendarHeight = calendarAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: [150, 360],
  });
  
  // Load sample appointments
  const loadSampleAppointments = async () => {
    try {
      // Check if we have stored sample data
      const storedAppointments = await AsyncStorage.getItem('sampleAppointments');
      
      if (storedAppointments) {
        setAppointments(JSON.parse(storedAppointments));
      } else {
        // Create sample appointments for demo
        const today = new Date();
        const tomorrow = new Date();
        tomorrow.setDate(today.getDate() + 1);
        
        const sampleData = [
          {
            id: '1',
            clientName: 'Ana García',
            service: 'Corte de cabello',
            date: today,
            time: '10:15',
            duration: 45,
            price: 25.00,
            confirmed: true,
            professionalId: 'prof1',
            professionalName: 'Carlos Méndez',
            professionalImage: 'https://randomuser.me/api/portraits/men/32.jpg',
            notes: 'Cliente regular, prefiere corte degradado',
            status: 'confirmed',
          },
          {
            id: '2',
            clientName: 'Roberto Sánchez',
            service: 'Afeitado completo',
            date: today,
            time: '11:30',
            duration: 30,
            price: 18.00,
            confirmed: true,
            professionalId: 'prof2',
            professionalName: 'Laura Torres',
            professionalImage: 'https://randomuser.me/api/portraits/women/44.jpg',
            notes: '',
            status: 'confirmed',
          },
          {
            id: '3',
            clientName: 'Sofía Martínez',
            service: 'Coloración',
            date: tomorrow,
            time: '09:30',
            duration: 90,
            price: 65.00,
            confirmed: false,
            professionalId: 'prof1',
            professionalName: 'Carlos Méndez',
            professionalImage: 'https://randomuser.me/api/portraits/men/32.jpg',
            notes: 'Primera vez, quiere cambio de look radical',
            status: 'pending',
          },
        ];
        
        await AsyncStorage.setItem('sampleAppointments', JSON.stringify(sampleData));
        setAppointments(sampleData);
      }
    } catch (error) {
      console.error('Error loading sample appointments:', error);
    }
  };
  
  // Fetch appointments for a specific date
  const fetchAppointmentsForDate = (date) => {
    if (!appointments.length) return;
    
    // Filter appointments for the selected date
    const filteredAppointments = appointments.filter(appointment => {
      const appointmentDate = new Date(appointment.date);
      return (
        appointmentDate.getDate() === date.getDate() &&
        appointmentDate.getMonth() === date.getMonth() &&
        appointmentDate.getFullYear() === date.getFullYear()
      );
    });
    
    // Sort appointments by time
    filteredAppointments.sort((a, b) => {
      return a.time.localeCompare(b.time);
    });
    
    return filteredAppointments;
  };
  
  // Generate days for the calendar
  const generateCalendarDays = () => {
    const daysInMonth = new Date(selectedYear, selectedMonth + 1, 0).getDate();
    const firstDayOfMonth = new Date(selectedYear, selectedMonth, 1).getDay();
    
    const days = [];
    
    // Add days from previous month to fill the first week
    const prevMonth = selectedMonth === 0 ? 11 : selectedMonth - 1;
    const prevYear = selectedMonth === 0 ? selectedYear - 1 : selectedYear;
    const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();
    
    for (let i = 0; i < firstDayOfMonth; i++) {
      const day = daysInPrevMonth - firstDayOfMonth + i + 1;
      days.push({
        day,
        month: prevMonth,
        year: prevYear,
        isCurrentMonth: false,
        date: new Date(prevYear, prevMonth, day),
      });
    }
    
    // Add days for the current month
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(selectedYear, selectedMonth, day);
      days.push({
        day,
        month: selectedMonth,
        year: selectedYear,
        isCurrentMonth: true,
        date,
        isToday: date.toDateString() === new Date().toDateString(),
        hasAppointments: appointments.some(appointment => {
          const appointmentDate = new Date(appointment.date);
          return appointmentDate.toDateString() === date.toDateString();
        }),
      });
    }
    
    // Add days from next month to complete the last week
    const nextMonth = selectedMonth === 11 ? 0 : selectedMonth + 1;
    const nextYear = selectedMonth === 11 ? selectedYear + 1 : selectedYear;
    const daysToAdd = 42 - days.length; // 6 weeks * 7 days = 42
    
    for (let day = 1; day <= daysToAdd; day++) {
      days.push({
        day,
        month: nextMonth,
        year: nextYear,
        isCurrentMonth: false,
        date: new Date(nextYear, nextMonth, day),
      });
    }
    
    setCalendarDays(days);
    
    // Scroll to selected date in horizontal calendar
    if (scrollViewRef.current && viewMode === 'day') {
      const today = new Date();
      const currentDayIndex = days.findIndex(day => 
        day.isCurrentMonth && day.day === today.getDate()
      );
      
      if (currentDayIndex !== -1) {
        setTimeout(() => {
          scrollViewRef.current.scrollTo({
            x: (currentDayIndex - 2) * (width / 7),
            animated: true,
          });
        }, 100);
      }
    }
  };
  
  // Navigate to previous month
  const goToPrevMonth = () => {
    if (selectedMonth === 0) {
      setSelectedMonth(11);
      setSelectedYear(selectedYear - 1);
    } else {
      setSelectedMonth(selectedMonth - 1);
    }
  };
  
  // Navigate to next month
  const goToNextMonth = () => {
    if (selectedMonth === 11) {
      setSelectedMonth(0);
      setSelectedYear(selectedYear + 1);
    } else {
      setSelectedMonth(selectedMonth + 1);
    }
  };
  
  // Ir al día actual
  const goToToday = () => {
    const today = new Date();
    const todayMonth = today.getMonth();
    const todayYear = today.getFullYear();
    
    // Actualizar mes y año si son diferentes
    if (todayMonth !== selectedMonth || todayYear !== selectedYear) {
      setSelectedMonth(todayMonth);
      setSelectedYear(todayYear);
    }
    
    // Seleccionar el día actual
    selectDate(today);
  };
  
  // Select a date
  const selectDate = (date) => {
    setSelectedDate(date);
    if (isCalendarExpanded) {
      setIsCalendarExpanded(false);
    }
  };
  
  // Toggle calendar view
  const toggleCalendarView = () => {
    setIsCalendarExpanded(!isCalendarExpanded);
  };
  
  // Using formatTime from imported utils
  
  // Using calculateEndTime from imported utils
  
  // Create a new appointment
  const createNewAppointment = () => {
    // Navigate to appointment creation screen with selected date and time if available
    navigation.navigate('BookAppointment', { 
      selectedDate: selectedDate,
      selectedTime: selectedTimeSlot
    });
  };
  
  // Day view component for horizontal scrolling calendar
  const renderDayItem = ({ item, index }) => {
    const isSelected = selectedDate.toDateString() === item.date.toDateString();
    const today = new Date();
    const isToday = item.date.toDateString() === today.toDateString();
    
    return (
      <TouchableOpacity
        style={[
          styles.dayItem,
          isSelected && styles.selectedDayItem,
          !item.isCurrentMonth && styles.otherMonthDayItem,
          isToday && !isSelected && styles.todayDayItem,
        ]}
        onPress={() => selectDate(item.date)}
      >
        <Text style={[
          styles.dayOfWeekText,
          isSelected && styles.selectedDayText,
          !item.isCurrentMonth && styles.otherMonthDayText,
        ]}>
          {daysOfWeek[item.date.getDay()]}
        </Text>
        <Text style={[
          styles.dayNumberText,
          isSelected && styles.selectedDayText,
          !item.isCurrentMonth && styles.otherMonthDayText,
        ]}>
          {item.day}
        </Text>
        {item.hasAppointments && (
          <View style={[styles.hasAppointmentsDot, isSelected && styles.selectedDotColor]} />
        )}
      </TouchableOpacity>
    );
  };
  
  // Render calendar week header
  const renderWeekDaysHeader = () => (
    <View style={styles.weekDaysHeader}>
      {daysOfWeek.map((day, index) => (
        <Text key={index} style={styles.weekDayText}>{day}</Text>
      ))}
    </View>
  );
  
  // Render month view calendar
  const renderMonthCalendar = () => {
    const chunks = [];
    for (let i = 0; i < calendarDays.length; i += 7) {
      chunks.push(calendarDays.slice(i, i + 7));
    }
    
    return (
      <View style={styles.monthCalendarContainer}>
        {renderWeekDaysHeader()}
        {chunks.map((week, weekIndex) => (
          <View key={`week-${weekIndex}`} style={styles.weekRow}>
            {week.map((day, dayIndex) => {
              const isSelected = selectedDate.toDateString() === day.date.toDateString();
              const isToday = day.isToday;
              
              return (
                <TouchableOpacity
                  key={`day-${weekIndex}-${dayIndex}`}
                  style={[
                    styles.calendarDay,
                    !day.isCurrentMonth && styles.otherMonthDay,
                    isSelected && styles.selectedDay,
                    isToday && styles.today,
                  ]}
                  onPress={() => selectDate(day.date)}
                >
                  <Text style={[
                    styles.calendarDayText,
                    !day.isCurrentMonth && styles.otherMonthDayText,
                    isSelected && styles.selectedDayText,
                    isToday && !isSelected && styles.todayText,
                  ]}>
                    {day.day}
                  </Text>
                  {day.hasAppointments && (
                    <View style={[
                      styles.appointmentIndicator,
                      isSelected && styles.selectedAppointmentIndicator,
                    ]} />
                  )}
                </TouchableOpacity>
              );
            })}
          </View>
        ))}
      </View>
    );
  };
  
  // Render a time slot
  const renderTimeSlot = (time, isOccupied = false, appointment = null) => {
    const isSelected = selectedTimeSlot === time;
    
    if (isOccupied && appointment) {
      return (
        <TouchableOpacity 
          key={`appointment-${appointment.id}`}
          style={[
            styles.appointmentSlot,
            appointment.status === 'confirmed' ? styles.confirmedAppointment : styles.pendingAppointment,
          ]}
          onPress={() => {
            // Show appointment details
            navigation.navigate('AppointmentDetails', { appointment });
          }}
        >
          <View style={styles.appointmentHeader}>
            <Text style={styles.appointmentTime}>
              {formatTime(appointment.time)} - {formatTime(calculateEndTime(appointment.time, appointment.duration))}
            </Text>
            <View style={styles.appointmentStatus}>
              <View style={[
                styles.statusDot,
                { backgroundColor: appointment.status === 'confirmed' ? '#10B981' : '#FBBF24' }
              ]} />
              <Text style={styles.appointmentStatusText}>
                {appointment.status === 'confirmed' ? 'Confirmado' : 'Pendiente'}
              </Text>
            </View>
          </View>
          
          <View style={styles.appointmentBody}>
            <View style={styles.appointmentClientInfo}>
              <View style={styles.serviceInfo}>
                <Text style={styles.appointmentService}>{appointment.service}</Text>
                <Text style={styles.appointmentDuration}>
                  {appointment.duration} min · ${appointment.price.toFixed(2)}
                </Text>
              </View>
            </View>
            
            <View style={styles.appointmentProfessionalInfo}>
              <Image 
                source={{ uri: appointment.professionalImage }} 
                style={styles.professionalImage}
              />
              <Text style={styles.professionalName}>{appointment.professionalName}</Text>
            </View>
          </View>
          
          <View style={styles.appointmentActions}>
            <TouchableOpacity style={styles.appointmentActionButton}>
              <Ionicons name="chatbubble-outline" size={16} color="#6B7280" />
              <Text style={styles.appointmentActionText}>Mensaje</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.appointmentActionButton}>
              <Ionicons name="pencil-outline" size={16} color="#6B7280" />
              <Text style={styles.appointmentActionText}>Editar</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={[styles.appointmentActionButton, styles.dangerAction]}>
              <Ionicons name="close-outline" size={16} color="#EF4444" />
              <Text style={[styles.appointmentActionText, styles.dangerActionText]}>Cancelar</Text>
            </TouchableOpacity>
          </View>
        </TouchableOpacity>
      );
    }
    
    return null;
  };
  
  // Generate time slots from 9:00 to 18:00 based on zoom level
  const generateTimeSlots = () => {
    const slots = [];
    let interval;
    
    // Define interval based on zoom level
    // Use fixed 15-minute intervals, can be adjusted by zoomScale for visual sizing
    interval = 15;
    
    for (let hour = 9; hour <= 18; hour++) {
      for (let minute = 0; minute < 60; minute += interval) {
        if (hour === 18 && minute > 0) continue; // End at 18:00
        
        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        slots.push(timeString);
      }
    }
    return slots;
  };
  
  // Get all appointments that overlap with a specific time slot
  const getAppointmentsForTimeSlot = (timeSlot) => {
    const appointmentsForDate = fetchAppointmentsForDate(selectedDate);
    if (!appointmentsForDate) return [];
    
    return appointmentsForDate.filter(appointment => {
      // Get appointment start and end time
      const startTime = appointment.time;
      const [startHour, startMinute] = startTime.split(':').map(Number);
      
      const endTime = calculateEndTime(startTime, appointment.duration);
      const [endHour, endMinute] = endTime.split(':').map(Number);
      
      // Convert current time slot to numbers for comparison
      const [slotHour, slotMinute] = timeSlot.split(':').map(Number);
      
      // Calculate total minutes for easy comparison
      const slotTotalMinutes = slotHour * 60 + slotMinute;
      const startTotalMinutes = startHour * 60 + startMinute;
      const endTotalMinutes = endHour * 60 + endMinute;
      
      // Check if this slot is within appointment time range
      return slotTotalMinutes >= startTotalMinutes && slotTotalMinutes < endTotalMinutes;
    });
  };
  
  // Calculate how many slots an appointment spans
  const getAppointmentDurationInSlots = (appointment) => {
    // Using fixed 15-minute slot intervals for consistent timing
    const slotDuration = 15;
    
    return Math.ceil(appointment.duration / slotDuration);
  };
  
  // Render appointments for the selected date in timeline view
  const renderAppointmentsForSelectedDate = () => {
    const timeSlots = generateTimeSlots();
    const appointmentsForDate = fetchAppointmentsForDate(selectedDate);
    
    // Siempre mostraremos la plantilla de horas, incluso cuando no haya turnos
    // Solo cambiamos lo que se muestra en el área de turnos
    
    // Create an array of rendered appointment blocks to avoid duplicates
    const renderedAppointments = new Set();
    
    return (
      // Usar solo el gesto de pellizco directamente para evitar conflictos
      <GestureDetector gesture={pinchGesture}>
        <ScrollView 
          ref={timelineScrollRef}
          style={styles.timelineContainer}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={{ paddingBottom: 0 }} // Eliminamos el padding inferior por completo
          // Configuración para evitar el warning de VirtualizedList
          removeClippedSubviews={false}
          nestedScrollEnabled={true}
          // Capturamos la posición de scroll actual para mantenerla durante el zoom
          onScroll={(e) => {
            currentScrollPosition.current = e.nativeEvent.contentOffset.y;
          }}
          scrollEventThrottle={16} // Frecuencia de actualización (60fps)
        >
        
        <View style={styles.timelineContent}>
          {/* Left column: Time labels */}
          <View style={styles.timeLabelsColumn}>
            {timeSlots.map((slot, index) => {
              // Usamos la función global getSlotHeight
              
              // Mostrar siempre todas las etiquetas de tiempo (horas, 15, 30, 45)
              const shouldShowLabel = () => {
                const [hour, minute] = slot.split(':').map(Number);
                // Siempre mostrar marcadores de tiempo en intervalos de 15 minutos
                return minute % 15 === 0; // Muestra todas las marcas (00, 15, 30, 45)
              };
              
              // Determinar el tipo de etiqueta para estilizado diferencial
              const isFullHourLabel = slot.endsWith(':00');
              const isHalfHourLabel = slot.endsWith(':30');
              const isQuarterHourLabel = slot.endsWith(':15') || slot.endsWith(':45');
              
              // Solo renderizar si debe mostrarse la etiqueta
              if (!shouldShowLabel()) return null;
              
              return (
                <View 
                  key={`time-${index}`} 
                  style={[
                    styles.timeLabel, 
                    { height: getSlotHeight() }
                  ]}
                >
                  <Text 
                    style={[
                      styles.timeLabelText,
                      // Estilo más compacto, alineado a la línea superior
                      {
                        fontSize: isFullHourLabel ? 10 : 9, // Ajustado para el formato con a.m./p.m.
                        fontWeight: isFullHourLabel ? '500' : '400',
                        color: isFullHourLabel ? '#333333' : '#9CA3AF',
                        opacity: 1,
                        textAlign: 'right',
                        marginRight: isFullHourLabel ? 0 : 0, // Eliminado el margen para minutos
                        marginTop: 0, // Alineado exactamente con la línea superior
                        height: getSlotHeight() * 0.8, // Altura controlada para mejor alineación
                      }
                    ]}
                    numberOfLines={1}
                  >
                    {isFullHourLabel ? 
                      // Formato con horas y a.m./p.m. como solicitado
                      `${parseInt(slot.split(':')[0]) > 12 ? parseInt(slot.split(':')[0]) - 12 : parseInt(slot.split(':')[0])}${parseInt(slot.split(':')[0]) >= 12 ? 'p.m.' : 'a.m.'}` : 
                      slot.split(':')[1]} {/* Solo mostrar minutos para 15, 30, 45 */}
                  </Text>
                </View>
              );
            })}
          </View>
          
          {/* Right column: Appointment slots */}
          <View style={styles.appointmentSlotsColumn}>
            {/* Hour divider lines */}
            {timeSlots.map((slot, index) => {
              // Usamos la función global getSlotHeight
              
              // Siempre mostrar todas las líneas divisorias de 15 minutos
              const shouldShowDivider = () => {
                const [hour, minute] = slot.split(':').map(Number);
                // Siempre mostrar líneas cada 15 minutos para mayor fluidez visual
                return minute % 15 === 0;
              };
              
              // Determinar el estilo de la línea
              const isFullHourDivider = slot.endsWith(':00');
              const isHalfHourDivider = slot.endsWith(':30');
              const isQuarterHourDivider = slot.endsWith(':15') || slot.endsWith(':45');
              
              // Solo renderizar si debe mostrarse la línea
              if (!shouldShowDivider()) return null;
              
              // Configuración de estilo para líneas similar a Boosky
              let opacity = 1;
              let height = 1;
              let backgroundColor = '#E9EAEE';
              let borderStyle = 'solid'; // Líneas continuas como solicitado
              
              if (isFullHourDivider) {
                // Horas completas - estilo Boosky más limpio
                opacity = 1;
                height = 1;
                backgroundColor = '#DFE1E6'; // Gris medio como en Boosky
              } else if (isHalfHourDivider) {
                // Medias horas
                opacity = 0.9;
                height = 1;
                backgroundColor = '#E5E7EC'; // Gris un poco más claro
              } else if (isQuarterHourDivider) {
                // Cuartos de hora
                opacity = 0.7;
                height = 1; // Mismo grosor para todas las líneas como en Boosky
                backgroundColor = '#EBEDF2'; // Gris muy claro
              }
              
              return (
                <View 
                  key={`divider-${index}`} 
                  style={[
                    styles.hourDivider, 
                    { 
                      top: index * getSlotHeight(),
                      opacity: opacity,
                      height: height,
                      backgroundColor: backgroundColor,
                      // Sin sombras para un aspecto más plano como en Boosky
                    },
                    isFullHourDivider && styles.fullHourDivider
                  ]} 
                />
              );
            })}
            
            {/* Time slots - solo para citas, sin slots vacíos que duplican líneas */}
            {timeSlots.map((timeSlot, index) => {
              const appointments = getAppointmentsForTimeSlot(timeSlot);
              
              // Si no hay citas en este horario, no renderizamos nada visual
              // Solo dejamos un receptor de toques invisible para la interactividad
              if (appointments.length === 0 || 
                  appointments.every(apt => renderedAppointments.has(apt.id))) {
                return (
                  <TouchableOpacity 
                    key={`slot-${index}`} 
                    style={{
                      position: 'absolute',
                      left: 0,
                      right: 0,
                      height: getSlotHeight(),
                      top: index * getSlotHeight(),
                      zIndex: 10,
                      backgroundColor: 'transparent' // Completamente transparente
                    }}
                    onPress={() => {
                      setSelectedTimeSlot(timeSlot);
                      // Abrir la pantalla para agendar un turno
                      navigation.navigate('BookAppointment', { selectedTime: timeSlot, selectedDate: selectedDate });
                    }}
                  />
                );
              }
              
              // Filtrar solo las citas no renderizadas aún
              const appointmentsToRender = appointments
                .filter(apt => !renderedAppointments.has(apt.id));
              
              // Si tenemos múltiples citas en el mismo horario
              if (appointmentsToRender.length > 0) {
                // Marcar estas citas como renderizadas
                appointmentsToRender.forEach(apt => renderedAppointments.add(apt.id));
                
                // Contenedor para múltiples citas con posicionamiento absoluto para mantener la alineación con la línea de tiempo
                return (
                  <View 
                    key={`slot-container-${index}`}
                    style={[
                      styles.multipleAppointmentsContainer,
                      {
                        position: 'absolute',
                        top: index * getSlotHeight(),
                        left: 0,
                        right: 0,
                        zIndex: 30, // Mayor que otros elementos para asegurar visibilidad
                      }
                    ]}
                  >
                    {appointmentsToRender.map((appointment, aptIndex) => {
                      // Calcular slots que ocupa esta cita
                      const slotsCount = getAppointmentDurationInSlots(appointment);
                      
                      // Siempre usamos la mitad del ancho como solicitado (para 2 columnas)
                      // Independientemente de la cantidad de citas
                      const appointmentWidth = '48%';
                      
                      return (
                        <TouchableOpacity 
                          key={`apt-${appointment.id}`}
                          style={[
                            styles.appointmentBlock,
                            { 
                              height: slotsCount * 30, // Altura según duración
                              width: appointmentWidth,
                              paddingTop: 0, // Sin padding superior para alinear con la línea
                              paddingBottom: 0, // Sin padding inferior para alinear con la línea
                              paddingHorizontal: 6, // Padding horizontal reducido para compactar
                            },
                            appointment.status === 'confirmed' ? styles.confirmedAppointment : styles.pendingAppointment,
                            index % 4 === 0 && styles.hourStartSlot,
                            aptIndex > 0 && styles.adjacentAppointment, // Estilo especial para citas adicionales
                            appointment.duration <= 15 && styles.shortAppointment // Estilo para citas cortas (5-15 min)
                          ]}
                          onPress={() => navigation.navigate('AppointmentDetails', { appointment })}
                        >
                          {/* Nombre del cliente primero */}
                          <Text style={[
                            styles.appointmentClientName, 
                            appointment.duration <= 15 && styles.shortAppointmentClientName
                          ]} numberOfLines={1}>
                            {appointment.clientName}
                          </Text>
                          
                          {/* Rango de horas debajo */}
                          <Text style={styles.appointmentTimeRange} numberOfLines={1}>
                            {formatTime(appointment.time)} - {formatTime(calculateEndTime(appointment.time, appointment.duration))}
                          </Text>
                          
                          {/* Solo mostramos el servicio si la cita es de más de 15 minutos */}
                          {appointment.duration > 15 && (
                            <Text style={styles.appointmentServiceCompact} numberOfLines={1}>{appointment.service}</Text>
                          )}
                          
                          {/* Indicador de estado (punto de color) */}
                          <View style={[
                            styles.statusDotCompact,
                            { backgroundColor: appointment.status === 'confirmed' ? '#10B981' : '#FBBF24' }
                          ]} />
                        </TouchableOpacity>
                      );
                    })}
                  </View>
                );
              }
              
              // Empty slot - sin elementos visuales que dupliquen líneas
              return (
                <TouchableOpacity 
                  key={`slot-${index}`} 
                  style={{
                    position: 'absolute',
                    left: 0,
                    right: 0,
                    height: getSlotHeight(),
                    top: index * getSlotHeight(),
                    zIndex: 10,
                    backgroundColor: selectedTimeSlot === timeSlot ? 'rgba(249, 230, 230, 0.3)' : 'transparent'
                  }}
                  onPress={() => {
                    setSelectedTimeSlot(timeSlot);
                    // Open booking screen with this time pre-selected
                    navigation.navigate('BookAppointment', { selectedTime: timeSlot, selectedDate: selectedDate });
                  }}
                />
              );
            })}
          </View>
        </View>
        
        {/* Current time indicator */}
        {isSameDay(selectedDate, new Date()) && (
          <View style={[
            styles.currentTimeIndicator, 
            { top: calculateCurrentTimePosition() }
          ]}>
            <View style={styles.currentTimeIndicatorDot} />
            <View style={styles.currentTimeIndicatorLine} />
          </View>
        )}
      </ScrollView>
      </GestureDetector>
    );
  };

  // Efecto para hacer scroll automático a la hora actual cuando se carga la pantalla
  // El efecto existente en líneas 135-150 ya maneja esto, así que no necesitamos uno nuevo

  return (
    <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
      <StatusBar backgroundColor="#FFFFFF" barStyle="dark-content" translucent={false} />
      
      {/* Cabecera fija que incluye el calendario */}
      <View style={styles.fixedHeader}>
        <Animated.View style={[styles.calendarContainer, { height: calendarHeight, minHeight: 150 }]}>
          <View style={styles.calendarHeader}>
            <TouchableOpacity onPress={toggleCalendarView} style={styles.monthYearContainer}>
              <Text style={styles.monthYearText}>
                {formatSelectedDate(selectedDate)}
              </Text>
              <Ionicons 
                name={isCalendarExpanded ? "chevron-up" : "chevron-down"} 
                size={20} 
                color={colors.text} 
              />
            </TouchableOpacity>
            
            <View style={styles.navigationButtons}>
              <TouchableOpacity onPress={goToPrevMonth} style={styles.navButton}>
                <Ionicons name="chevron-back" size={22} color={colors.text} />
              </TouchableOpacity>
              <TouchableOpacity onPress={goToToday} style={[styles.navButton, styles.todayButton]}>
                <Text style={styles.todayButtonText}>Hoy</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          {isCalendarExpanded ? (
            renderMonthCalendar()
          ) : (
            <ScrollView 
              horizontal 
              showsHorizontalScrollIndicator={false} 
              contentContainerStyle={styles.daysScrollView}
              ref={scrollViewRef}
              style={{minHeight: 80}}
            >
              {calendarDays.filter(day => day.isCurrentMonth).map((day, index) => (
                <View key={`day-${index}`}>
                  {renderDayItem({ item: day, index })}
                </View>
              ))}
            </ScrollView>
          )}
        </Animated.View>
      </View>
      
      {/* Contenido scrollable (timeline) */}
      <View style={styles.appointmentsContainer}>
        {renderAppointmentsForSelectedDate()}
      </View>
      
      <TouchableOpacity
        style={styles.fabButton}
        onPress={createNewAppointment}
      >
        <Ionicons name="add" size={30} color="#FFFFFF" />
      </TouchableOpacity>
    </SafeAreaView>
  );
}
    backgroundColor: '#FFFFFF',
    zIndex: 10,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    // Eliminamos la línea inferior
  },
  scrollContainer: {
    flex: 1,
  },
  scrollContentContainer: {
    flexGrow: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#F3F4F6',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#111827',
  },
  headerButtons: {
    flexDirection: 'row',
    backgroundColor: '#F3F4F6',
    borderRadius: 8,
    padding: 2,
  },
  viewModeButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  activeViewModeButton: {
    backgroundColor: '#FFFFFF',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  viewModeText: {
    fontSize: 13,
    color: '#6B7280',
  },
  activeViewModeText: {
    color: '#111827',
    fontWeight: '500',
  },
  calendarContainer: {
    backgroundColor: '#FFFFFF',
    paddingBottom: 5, // Reducimos el padding inferior
    paddingTop: 5,
    overflow: 'visible',
    marginBottom: 0, // Quitamos el margen inferior
    // Eliminamos la línea horizontal
  },
  calendarHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  monthYearContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  monthYearText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginRight: 4,
  },
  navigationButtons: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  navButton: {
    padding: 4,
    marginLeft: 8,
  },
  todayButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
  },
  todayButtonText: {
    color: '#FFFFFF',
    fontWeight: '500',
    fontSize: 14,
  },
  daysScrollView: {
    paddingLeft: 8,
    paddingRight: 8,
    paddingBottom: 12,
    paddingTop: 8,
    minHeight: 80,
    alignItems: 'center',
  },
  dayItem: {
    width: width / 7 - 8,
    height: 60,
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 4,
    marginBottom: 5,
    borderRadius: 10,
    backgroundColor: '#FFFFFF',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
  },
  selectedDayItem: {
    backgroundColor: colors.primary,
    height: 60,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 3,
  },
  otherMonthDayItem: {
    opacity: 0.4,
  },
  todayDayItem: {
    borderWidth: 2,
    borderColor: colors.primary,
  },
  dayOfWeekText: {
    fontSize: 13,
    color: '#6B7280',
    marginBottom: 4,
  },
  dayNumberText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
  },
  selectedDayText: {
    color: '#FFFFFF',
  },
  otherMonthDayText: {
    color: '#9CA3AF',
  },
  hasAppointmentsDot: {
    width: 4,
    height: 4,
    borderRadius: 2,
    backgroundColor: colors.primary,
    marginTop: 4,
  },
  selectedDotColor: {
    backgroundColor: '#FFFFFF',
  },
  weekDaysHeader: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#F3F4F6',
  },
  weekDayText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#6B7280',
    width: width / 7,
    textAlign: 'center',
  },
  monthCalendarContainer: {
    flex: 1,
    paddingHorizontal: 8,
  },
  weekRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 8,
  },
  calendarDay: {
    width: width / 7 - 10,
    height: 36,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 18,
  },
  otherMonthDay: {
    opacity: 0.4,
  },
  selectedDay: {
    backgroundColor: colors.primary,
  },
  today: {
    borderWidth: 2,
    borderColor: colors.primary,
  },
  calendarDayText: {
    fontSize: 15,
    fontWeight: '500',
    color: '#111827',
  },
  todayText: {
    color: colors.primary,
    fontWeight: 'bold',
  },
  appointmentIndicator: {
    width: 4,
    height: 4,
    borderRadius: 2,
    backgroundColor: colors.primary,
    marginTop: 2,
  },
  selectedAppointmentIndicator: {
    backgroundColor: '#FFFFFF',
  },
  appointmentsContainer: {
    flex: 1,
    paddingTop: 0, // Eliminamos el padding superior
    paddingBottom: 0, // Eliminamos todo el padding inferior
    width: '100%', // Aseguramos ancho completo
    backgroundColor: '#FFFFFF', // Fondo blanco
  },
  dateHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  selectedDateText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
  },
  dateBadge: {
    backgroundColor: '#F3F4F6',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  dateBadgeText: {
    fontSize: 12,
    color: '#6B7280',
    fontWeight: '500',
  },
  timeSlotsList: {
    paddingBottom: 100,
  },
  appointmentSlot: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 2,
    borderLeftWidth: 4,
  },
  confirmedAppointment: {
    borderLeftColor: '#10B981',
  },
  pendingAppointment: {
    borderLeftColor: '#FBBF24',
  },
  appointmentHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  appointmentTime: {
    fontSize: 15,
    fontWeight: '600',
    color: '#111827',
  },
  appointmentStatus: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  appointmentStatusText: {
    fontSize: 13,
    color: '#6B7280',
  },
  appointmentBody: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  appointmentClientInfo: {
    flex: 1,
  },
  serviceInfo: {
    marginBottom: 4,
  },
  appointmentService: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 4,
  },
  appointmentDuration: {
    fontSize: 13,
    color: '#6B7280',
  },
  appointmentProfessionalInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  professionalImage: {
    width: 28,
    height: 28,
    borderRadius: 14,
    marginRight: 8,
  },
  professionalName: {
    fontSize: 13,
    color: '#6B7280',
    fontWeight: '500',
  },
  appointmentActions: {
    flexDirection: 'row',
    borderTopWidth: 1,
    borderTopColor: '#F3F4F6',
    paddingTop: 12,
  },
  appointmentActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 16,
  },
  appointmentActionText: {
    marginLeft: 4,
    fontSize: 13,
    color: '#6B7280',
  },
  dangerAction: {
    marginLeft: 'auto',
  },
  dangerActionText: {
    color: '#EF4444',
  },
  noAppointmentsContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingBottom: 80,
  },
  noAppointmentsText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
    marginTop: 12,
    marginBottom: 8,
  },
  noAppointmentsSubText: {
    fontSize: 14,
    color: '#6B7280',
    textAlign: 'center',
    marginBottom: 24,
    paddingHorizontal: 32,
  },
  createAppointmentButton: {
    backgroundColor: colors.primary,
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  createAppointmentText: {
    color: '#FFFFFF',
    fontWeight: '600',
    fontSize: 15,
  },
  fabButton: {
    position: 'absolute',
    bottom: 20, // Ajustamos para que esté más cerca del borde inferior
    right: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 5, // Mayor elevación para mejor efecto "flotante"
    zIndex: 1000, // Aseguramos que esté por encima de todo
  },
  
  // Timeline view styles
  timelineContainer: {
    flex: 1,
    backgroundColor: '#FFFFFF',
    marginBottom: 0, // Eliminamos el margen inferior
    minHeight: 300, // Altura mínima para asegurar visibilidad de contenido
    width: '100%',
    borderRadius: 0, // Quitamos los bordes redondeados
    // Quitamos todas las sombras para un diseño más limpio
    elevation: 0,
  },
  timelineHeader: {
    flexDirection: 'row',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F3F4F6',
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
  },
  timelineHeaderText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#6B7280',
  },
  timelineContent: {
    flexDirection: 'row',
    flex: 1,
  },
  timeLabelsColumn: {
    width: 48, // Reducido como solicitado
    backgroundColor: '#FFFFFF',
    alignItems: 'flex-end',
    paddingRight: 5, // Margen derecho más pequeño
    paddingTop: 0,
    borderRightWidth: 1,
    borderRightColor: '#F0F0F5',
  },
  appointmentSlotsColumn: {
    flex: 1,
    position: 'relative',
    backgroundColor: '#FFFFFF',
    paddingLeft: 4,
  },
  timeLabel: {
    // El alto se ajusta dinámicamente en el componente
    height: 120, // Valor predeterminado, será ajustado en tiempo de ejecución
    width: '100%',
    justifyContent: 'flex-start',
    alignItems: 'flex-end', // Alineación a la derecha
    paddingTop: 0, // Sin padding superior para que esté justo debajo de la línea
  },
  timeLabelText: {
    fontSize: 11,
    color: '#6B7280',
    fontWeight: '400',
  },
  timeLabelTextSmall: {
    fontSize: 9,
    fontWeight: '300',
    color: '#9CA3AF',
  },
  timeSlot: {
    height: 30,
    backgroundColor: 'transparent', // Transparente para evitar duplicación visual
    transition: 'background-color 0.2s ease',
  },
  hourStartSlot: {
    // Eliminamos bordes que duplican las líneas divisorias
  },
  selectedEmptySlot: {
    backgroundColor: '#F9E6E6',
  },
  appointmentBlock: {
    position: 'relative',
    padding: 4, // Padding reducido para mayor compactación
    backgroundColor: '#FFFFFF',
    borderRadius: 6, // Bordes más suaves
    marginHorizontal: 2, // Margen horizontal reducido
    marginVertical: 0, // Sin margen vertical para alinear exactamente con las líneas
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 2,
    elevation: 2, // Elevación reducida
    zIndex: 10,
    borderLeftWidth: 3,
    borderLeftColor: colors.primary,
    justifyContent: 'center', // Centrado vertical del contenido
    overflow: 'hidden', // Para evitar que el contenido se desborde
  },
  // Estilo especial para citas cortas (5-15 min)
  shortAppointment: {
    padding: 6, // Menos padding para optimizar espacio
  },
  // Estilo para el nombre del cliente en citas cortas
  shortAppointmentClientName: {
    fontSize: 14,
    fontWeight: '700', // Más destacado en las citas cortas
    marginBottom: 2, // Menos espacio al fondo
  },
  appointmentBlockHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  appointmentTimeRange: {
    fontSize: 11,
    fontWeight: '500',
    color: '#4B5563',
    marginBottom: 2,
  },
  hourDivider: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 1, // Grosor uniforme como en Boosky
    backgroundColor: '#E9EAEE', // Color base tipo Boosky
    zIndex: 2, // Específicamente bajo para evitar que cubra las interacciones
    // Líneas rectas sin bordes redondeados como en Boosky
    borderRadius: 0,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.02,
    shadowRadius: 1,
  },
  fullHourDivider: {
    backgroundColor: '#E0E0E5', // Color más elegante para horas completas
    height: 1.5, // Línea ligeramente más gruesa
  },
  currentTimeIndicator: {
    position: 'absolute',
    left: 0,
    right: 0,
    flexDirection: 'row',
    alignItems: 'center',
    zIndex: 20,
  },
  currentTimeIndicatorDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: colors.primary,
    marginLeft: 40,
    marginRight: -5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 4,
  },
  currentTimeIndicatorLine: {
    flex: 1,
    height: 1.5,
    backgroundColor: colors.primary,
    zIndex: 20,
    opacity: 0.8,
  },
  timelineProfessionalImage: {
    width: 22,
    height: 22,
    borderRadius: 11,
    marginRight: 6,
    borderWidth: 1,
    borderColor: '#F0F0F5',
  },
  timelineProfessionalName: {
    fontSize: 12,
    color: '#555555',
    fontWeight: '400',
    letterSpacing: 0.1,
  },
  appointmentClientName: {
    fontSize: 13,
    color: '#111827',
    fontWeight: '700', // Más bold para destacar
    marginBottom: 2, // Margen reducido
    letterSpacing: 0.2,
    paddingTop: 2, // Un pequeño padding superior
  },
  zoomControls: {
    flexDirection: 'row',
    position: 'absolute',
    right: 10,
    alignItems: 'center',
  },
  zoomButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginLeft: 4,
    backgroundColor: '#F3F4F6',
  },
  zoomButtonActive: {
    backgroundColor: colors.primary,
  },
  zoomButtonText: {
    fontSize: 10,
    fontWeight: '600',
    color: '#6B7280',
  },
  timeLabelText: {
    fontSize: 11, // Reducido significativamente para mejor ajuste con zoom
    fontWeight: '500',
    color: '#333333',
    letterSpacing: 0,
    fontFamily: 'System',
    textAlign: 'right',
    padding: 0, // Eliminado el padding para ajuste más preciso
  },
  timeLabelTextMedium: {
    fontSize: 9, // Reducido para minutos
    fontWeight: '400',
    color: '#9CA3AF',
    letterSpacing: 0,
  },
  timeLabelTextSmall: {
    fontSize: 9, // Mismo tamaño para todas las marcas de minutos
    fontWeight: '400',
    color: '#9CA3AF',
    letterSpacing: 0.1,
  },
  multipleAppointmentsContainer: {
    flexDirection: 'row',
    paddingHorizontal: 2,
    paddingVertical: 0, // Sin padding vertical para alinear con las líneas
    alignItems: 'flex-start',
    flexWrap: 'wrap', // Permitir que las tarjetas pasen a la siguiente fila
    justifyContent: 'space-between', // Distribuir el espacio entre las tarjetas
    position: 'absolute', // Posicionamiento absoluto para alinearse exactamente con las líneas
    minHeight: 30, // Altura mínima para asegurar visibilidad
    marginBottom: 0, // Sin margen inferior
    borderRadius: 0, // Sin bordes redondeados
    width: '100%', // Ancho completo
    zIndex: 20, // Alto z-index para estar por encima de otros elementos
  },
  adjacentAppointment: {
    marginLeft: 4,
    marginRight: 4,
    borderLeftWidth: 3,
    borderLeftColor: '#3B82F6', // Color azul similar al theme para mejor identificación
  },
  // Nuevos estilos para la versión compacta
  appointmentServiceCompact: {
    fontSize: 10,
    color: '#6B7280',
    fontWeight: '400',
    marginTop: 0,
    marginBottom: 2,
  },
  shortAppointmentClientName: {
    fontSize: 12,
    fontWeight: '700',
    marginBottom: 0,
  },
  statusDotCompact: {
    width: 6,
    height: 6,
    borderRadius: 3,
    position: 'absolute',
    top: 3,
    right: 3,
  },
});
